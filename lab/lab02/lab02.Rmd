---
title: 'Lab 2: Table Operations'
output:
  html_document: default
  pdf_document: default
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Lab 2: Table Operations

Welcome to Lab 2! This week, we'll learn how to import libraries and practice table operations. The R equivalent focuses on using tidyverse packages for data manipulation.

**Recommended Reading**: \* [R for Data Science - Data Transformation](https://r4ds.had.co.nz/transform.html)

Let's begin by setting up the libraries and imports by running the cell below.

```{r libraries}
# Load required libraries (using base R for compatibility)
# If you have tidyverse installed, you can uncomment the lines below:
# library(tidyverse)
# library(readr)
# library(dplyr)

# Using base R functions for maximum compatibility
library(utils)  # For read.csv
```

# 1. Review: The Building Blocks of R Code

The building blocks of R code are *expressions* and *assignments*. An **expression** is a piece of code that:

-   is self-contained, meaning it would make sense to write it on a line by itself, and
-   usually evaluates to a value.

Here are two expressions that both evaluate to 3:

```{r basic_expressions}
3
5 - 2
```

One important type of expression is the **function call**. A function call begins with the name of a function and is followed by the argument(s) of that function in parentheses. Some important mathematical functions are listed below.

| Function    | Description                                                   |
|-------------|---------------------------------------------------------------|
| `abs`       | Returns the absolute value of its argument                    |
| `max`       | Returns the maximum of all its arguments                      |
| `min`       | Returns the minimum of all its arguments                      |
| `^` or `**` | Raises its first argument to the power of its second argument |
| `round`     | Rounds its argument to the nearest integer                    |

Here are two call expressions that both evaluate to 3:

```{r call_expressions}
abs(2 - 5)
max(round(2.8), min(2^10, -1 * 2^10))
```

An **assignment statement** assigns a value to a name using the `<-` operator in R.

```{r assignments}
height <- 1.3
the_number_five <- abs(-5)
absolute_height_difference <- abs(height - 1.688)
```

<img src="statement.png"/>

**Question 1.1.** In the next cell, assign the name `new_year` to the **larger number** among the following two numbers:

-   the **absolute value** of $2^{6}-2^{11}-2^{5} - 7$, and
-   $5 \times 13 \times 31 + 9$.

Try to use just one statement (one line of code).

```{r q11}
new_year <- 0
new_year
```

```{r q11_test}
# Test: Should equal 2024
if (new_year == 2024) {
  cat("✓ Test passed: new_year =", new_year)
} else {
  stop("Test failed: new_year =", new_year)
}
```

# 1.2 Programming Practices in R: Variable Naming

As a note, it is important not to use variable names that are the same as an existing function name. Take the `max` function for example.

Currently, it works as expected:

```{r max_demo1}
print(max) # shows us that this is currently a function
max(5, 6, 7) # returns 7, as expected
```

If we use `max` as a variable name, we will no longer be able to use the max function (thus, don't do this!):

```{r max_demo2, error=TRUE}
max <- 8 # you should not do this!
print(max) # it now prints the number 8
# max(5, 6, 7) # this would cause an error!
```

Run this cell below to revert the max function back to normal:

```{r max_restore}
rm(max) # Remove the variable to restore the function
```

# 2. Importing Code

Most programming involves work that is very similar to work that has been done before. Since writing code is time-consuming, it's good to rely on others' published code when you can. Rather than copy-pasting, R allows us to **load libraries**. A library is a collection of R functions and data sets. By loading a library, we are able to use its code in our own script.

R includes many useful libraries that are just a `library()` call away. We'll look at base R math functions as a first example.

Suppose we want to very accurately compute the area of a circle with a radius of 5 meters. For that, we need the constant $\pi$, which is roughly 3.14. Conveniently, R has `pi` defined for us:

```{r circle_area}
radius <- 5
area_of_circle <- radius^2 * pi
area_of_circle
```

**Question 2.1.** R also provides the name `exp(1)` for the base of the natural logarithm (e), which is roughly 2.71. Compute $e^{\pi}-\pi$, giving it the name `near_twenty`.

```{r q21}
near_twenty <- 0
near_twenty
```

```{r q21_test}
# Test: Should be approximately 19.999
if (abs(round(near_twenty, 8) - 19.99909998) < 0.00000001) {
  cat("✓ Test passed: near_twenty =", round(near_twenty, 8))
} else {
  stop("Test failed: near_twenty =", round(near_twenty, 8))
}
```

## 2.1. Accessing Functions

In the question above, you accessed variables within base R.

**Functions** are also available in base R. For example, R provides the `floor` function for the floor function. We can write `floor(7.5)` to compute the floor of 7.5. (Note that the floor function returns the largest integer less than or equal to a given number.)

**Question 2.1.1.** Compute the floor of pi using `floor` and `pi` from base R. Give the result the name `floor_of_pi`.

```{r q211}
floor_of_pi <- 0
floor_of_pi
```

```{r q211_test}
# Test: Should equal 3
if (floor_of_pi == 3) {
  cat("✓ Test passed: floor_of_pi =", floor_of_pi)
} else {
  stop("Test failed: floor_of_pi =", floor_of_pi)
}
```

For your reference, below are some more examples of functions from base R:

```{r math_examples}
# Calculating logarithms (the logarithm of 8 in base 2)
# The result is 3 because 2 to the power of 3 is 8
log(8, base = 2)

# Calculating square roots
sqrt(5)
```

There are various ways to access functions in R. We can use base R functions directly, or load specific packages. The method we used above uses base R functions directly.

We can also load specific packages for additional functionality:

```{r package_demo}
# Try to load tidyverse at the beginning
# This gives us access to functions like filter(), select(), etc.
#
```

Let's move on to practicing some of the table operations!

# 3. Table Operations

The table `farmers_markets.csv` contains data on farmers' markets in the United States (data associated with [the USDA](https://apps.ams.usda.gov/FarmersMarketsExport/ExcelExport.aspx)). Each row represents one such market.

Run the next cell to load the `farmers_markets` table:

```{r load_farmers_markets}
farmers_markets <- read.csv('farmers_markets.csv', stringsAsFactors = FALSE)
```

Let's examine our table to see what data it contains.

**Question 3.1.** Use the `head()` function to display the first 5 rows of `farmers_markets`.

```{r q31}
head(farmers_markets, 5)
```

Notice that some of the values in this table are missing, as denoted by "NA." This means either that the value is not available (e.g. if we don't know the market's street address) or not applicable (e.g. if the market doesn't have a street address). You'll also notice that the table has a large number of columns in it!

### `ncol()` - Number of Columns

The function `ncol()` returns the number of columns in a data frame.

**Question 3.2.** Use `ncol()` to find the number of columns in our farmers' markets dataset.

Assign the number of columns to `num_farmers_markets_columns`.

```{r q32}
num_farmers_markets_columns <- 0
cat("The table has", num_farmers_markets_columns, "columns in it!")
```

```{r q32_test}
# Test: Should equal 59
if (num_farmers_markets_columns == 59) {
  cat("✓ Test passed: num_farmers_markets_columns =", num_farmers_markets_columns)
} else {
  stop("Test failed: num_farmers_markets_columns =", num_farmers_markets_columns)
}
```

### `nrow()` - Number of Rows

Similarly, the function `nrow()` tells you how many rows are in a data frame.

```{r num_rows}
num_farmers_markets_rows <- 0
cat("The table has", num_farmers_markets_rows, "rows in it!")
```

### Column Selection

Most of the columns are about particular products -- whether the market sells tofu, pet food, etc. If we're not interested in that information, it just makes the table difficult to read. This comes up more than you might think, because people who collect and publish data may not know ahead of time what people will want to do with it.

In such situations, we can use column selection with square brackets to choose only the columns that we want in a particular table. We specify the column names as a character vector. It returns a new data frame with only those columns in it.

For example, `farmers_markets[, c("MarketName", "State")]` creates a table with only the name and the state of each farmers' market.

**Question 3.3.** Use column selection to create a table with only the name, city, state, latitude (`y`), and longitude (`x`) of each market. Call that new table `farmers_markets_locations`.

```{r q33}
farmers_markets_locations <- farmers_markets
head(farmers_markets_locations, 5)
```

```{r q33_test}
# Test: Should have correct columns and row count
expected_cols <- c("MarketName", "city", "State", "y", "x")
if (all(names(farmers_markets_locations) %in% expected_cols)) {
  cat("✓ Test passed: farmers_markets_locations has correct columns")
} else {
  stop("Test failed: farmers_markets_locations has incorrect columns")
}
```

### Column Exclusion - Dropping Columns

Column selection can also be used to drop columns by using logical indexing with `%in%` and negation. This serves the same purpose as selecting specific columns, but it takes away the columns that you provide rather than keeping only the ones you specify.

**Question 3.4.** Suppose you just didn't want the `FMID` and `updateTime` columns in `farmers_markets`. Create a table that's a copy of `farmers_markets` but doesn't include those columns. Call that table `farmers_markets_without_fmid`.

```{r q34}
farmers_markets_without_fmid <- farmers_markets
head(farmers_markets_without_fmid, 5)
```

```{r q34_test}
# Test: Should have 57 columns (59 - 2)
tryCatch({
  stopifnot(ncol(farmers_markets_without_fmid) == 57)
  stopifnot(!("FMID" %in% names(farmers_markets_without_fmid)))
  stopifnot(!("updateTime" %in% names(farmers_markets_without_fmid)))
  cat("✓ Test passed: farmers_markets_without_fmid has correct structure")
}, error = function(e) {
  stop("Test failed: ", e$message)
})
```

Now, suppose we want to answer some questions about farmers' markets in the US. For example, which market(s) have the largest longitude (given by the `x` column)?

To answer this, we'll sort `farmers_markets_locations` by longitude:

```{r sort_demo1}
farmers_markets_locations <- farmers_markets_locations[order(farmers_markets_locations$x), ]
head(farmers_markets_locations, 5)
```

Oops, that didn't answer our question because we sorted from smallest to largest longitude. To look at the largest longitudes, we'll have to sort in reverse order:

```{r sort_demo2}
farmers_markets_locations[order(farmers_markets_locations$x, decreasing = TRUE), ]
```

### `order()` - Sorting

Some details about `order()`:

1.  `order()` returns the indices that would sort the data frame.
2.  If the column has text in it, `order()` will sort alphabetically; if the column has numbers, it will sort numerically - both in ascending order by default.
3.  Use `decreasing = TRUE` to sort in descending order.
4.  The result is a *copy* of the original data frame; the original doesn't get modified.
5.  Rows always stick together when a table is sorted.

**Question 3.5.** Create a version of `farmers_markets_locations` that's sorted by **latitude (`y`)**, with the largest latitudes first. Call it `farmers_markets_locations_by_latitude`.

```{r q35}

```

```{r q35_test}
# Test: Check that it's sorted correctly
if (abs(round(second_y_value, 4) - 64.8459) < 0.0001) {
  cat("✓ Test passed: farmers_markets_locations_by_latitude is sorted correctly")
} else {
  stop("Test failed: farmers_markets_locations_by_latitude is not sorted correctly")
}
```

Now let's say we want a table of all farmers' markets in California. Sorting won't help us much here because California is closer to the middle of the dataset.

Instead, we use logical indexing to filter rows:

```{r filter_demo}

```

### Logical Indexing - Filtering Rows

Logical indexing takes a data frame and one or more logical conditions. It returns a new data frame that contains only the rows where the conditions are TRUE.

**Question 3.6.** Use `california_farmers_markets` to create a table called `berkeley_markets` containing farmers' markets in Berkeley, California.

```{r q36}

```

```{r q36_test}
# Test: Should have 3 rows, all in Berkeley
if (all(berkeley_markets$city == "Berkeley")) {
  cat("✓ Test passed: berkeley_markets has correct structure")
} else {
  stop("Test failed: berkeley_markets has incorrect structure")
}
```

So far we've only been using logical indexing with equality conditions. However, there are many other comparison operators available:

| Operator | Example | Result |
|----|----|----|
| `==` | `x == 50` | Find rows where x equals 50 |
| `!=` | `x != 50` | Find rows where x does not equal 50 |
| `>` | `x > 50` | Find rows where x is greater than 50 |
| `>=` | `x >= 50` | Find rows where x is greater than or equal to 50 |
| `<` | `x < 50` | Find rows where x is less than 50 |
| `<=` | `x <= 50` | Find rows where x is less than or equal to 50 |
| `&` | `x >= 2 & x <= 10` | Find rows where x is between 2 and 10 (inclusive) |

## 4. Analyzing a Dataset

Now that you're familiar with table operations, let's answer an interesting question about a dataset!

Run the cell below to load the `imdb` table. It contains information about the 250 highest-rated movies on IMDb.

```{r load_imdb}
imdb <- read.csv('imdb.csv', stringsAsFactors = FALSE)
head(imdb, 5)
```

Often, we want to perform multiple operations - sorting, filtering, or others - in order to turn a table we have into something more useful. You can do these operations one by one:

```{r chaining_demo, eval=FALSE}
# Method: Step by step
first_step <- original_tbl[original_tbl$col1 == 12, ]
second_step <- first_step[order(first_step$col2, decreasing = TRUE), ]
```

**Question 4.1.** Create a table of movies released between 2010 and 2015 (inclusive) with ratings above 8. The table should only contain the columns `Title` and `Rating`, **in that order**.

Assign the table to the name `above_eight`.

```{r q41}
# Filter movies from 2010-2015 with rating > 8, then select Title and Rating columns
above_eight <- 0 
head(above_eight, 5)
```

```{r q41_test}
# Test: Should have 20 rows and correct structure
if (nrow(above_eight) == 20) {
  cat("✓ Test passed: above_eight has correct structure")
} else {
  stop("Test failed: above_eight has incorrect structure")
}
if (names(above_eight) == c("Title", "Rating")) {
  cat("✓ Test passed: above_eight has correct structure")
} else {
  stop("Test failed: above_eight has incorrect structure")
}

# Check for specific movie
if (above_eight[above_eight$Title == "Toy Story 3", ]$Rating == 8.3) {
  cat("✓ Test passed: above_eight has correct structure and content")
} else {
  stop("Test failed: above_eight has incorrect structure and content")
}
```

**Question 4.2.** Use `nrow()` (and arithmetic) to find the *proportion* of movies in the dataset that were released 1900-1999, and the *proportion* of movies in the dataset that were released in the year 2000 or later.

Assign `proportion_in_20th_century` to the proportion of movies in the dataset that were released 1900-1999, and `proportion_in_21st_century` to the proportion of movies in the dataset that were released in the year 2000 or later.

```{r q42}
num_movies_in_dataset <- nrow(imdb)
proportion_in_20th_century <- 0 
proportion_in_21st_century <- 0 

cat("Proportion in 20th century:", proportion_in_20th_century, "\n")
cat("Proportion in 21st century:", proportion_in_21st_century, "\n")
```

```{r q42_test}
# Test: Should equal specific proportions
if (proportion_in_20th_century == 0.684) {
  cat("✓ Test passed: proportion_in_20th_century =", proportion_in_20th_century)
} else {
  stop("Test failed: proportion_in_20th_century =", proportion_in_20th_century)
}
if (proportion_in_21st_century == 0.316) {
  cat("✓ Test passed: proportion_in_21st_century =", proportion_in_21st_century)
} else {
  stop("Test failed: proportion_in_21st_century =", proportion_in_21st_century)
}
```

## 5. Summary

For your reference, here's a table of all the functions and methods we saw in this lab:

| Name | Example | Purpose |
|----|----|----|
| `order()` | `df[order(df$col), ]` | Create a copy of a data frame sorted by the values in a column |
| Logical indexing | `df[df$col > 2, ]` | Create a copy of a data frame with only the rows that match some condition |
| `nrow()` | `nrow(df)` | Compute the number of rows in a data frame |
| `ncol()` | `ncol(df)` | Compute the number of columns in a data frame |
| Column selection | `df[, c("col1", "col2")]` | Create a copy of a data frame with only some of the columns |
| Column exclusion | `df[, !names(df) %in% c("col1")]` | Create a copy of a data frame without some of the columns |

**Lego** wants to congratulate you on finishing Lab 2!

<img src="lego.png" alt="Picture of brown cavalier poodle dog" width="300"/>

------------------------------------------------------------------------

You're done with lab!

**Important submission information:** - **Run all the code chunks** and verify that they all work - **Save** the file using Ctrl+S or Cmd+S - **Knit** the document to HTML to create the final output
